---
title: Editing Posts
slug: editing-posts
date: 0008/01/01
number: 8
contents: Add a form for editing your posts.|Set up edit permissions.|Restrict which properties can be edited.
paragraphs: 29
---

Nun, da wir Beiträge anlegen können ist der nächste Schritt, sie zu ändern und löschen. Weil der Code für die entsprechende UI einfach sein wird, nutzen wir die Gelegenheit um darüber zu sprechen wie Meteor mit Benutzerberechtigungen umgeht.

Zuerst verbinden wir unseren Router. Wir fügen eine Route für die Editierung des Beitrags ein und setzen den Kontext der Seite.

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});

  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postEdit', {
    path: '/posts/:_id/edit',
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    if (Meteor.loggingIn())
      this.render('loading')
    else
      this.render('accessDenied');
  
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "12~15" %>

### Das Template für die Beitragsänderung

Jetzt können wir uns das Template dazu anschauen. Das Template `postEdit` ist ein ziemlich gewöhnliches Formular:

~~~html
<template name="postEdit">
  <form class="main">
    <div class="control-group">
        <label class="control-label" for="url">URL</label>
        <div class="controls">
            <input name="url" type="text" value="{{url}}" placeholder="Your URL"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="title">Title</label>
        <div class="controls">
            <input name="title" type="text" value="{{title}}" placeholder="Name your post"/>
        </div>
    </div>

    <div class="control-group">
        <div class="controls">
            <input type="submit" value="Submit" class="btn btn-primary submit"/>
        </div>
    </div>
    <hr/>
    <div class="control-group">
        <div class="controls">
            <a class="btn btn-danger delete" href="#">Delete post</a>
        </div>
    </div>
  </form>
</template>
~~~
<%= caption "client/views/posts/post_edit.html" %>

Und hier ist der Manager `post_edit.js`, der dazu gehört:

~~~js
Template.postEdit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var currentPostId = this._id;
    
    var postProperties = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val()
    }
    
    Posts.update(currentPostId, {$set: postProperties}, function(error) {
      if (error) {
        // display the error to the user
        alert(error.reason);
      } else {
        Router.go('postPage', {_id: currentPostId});
      }
    });
  },
  
  'click .delete': function(e) {
    e.preventDefault();
    
    if (confirm("Delete this post?")) {
      var currentPostId = this._id;
      Posts.remove(currentPostId);
      Router.go('postsList');
    }
  }
});
~~~
<%= caption "client/views/posts/post_edit.js" %>

Mittlerweile sollte der meiste Code dir vertraut erscheinen. Zuerst haben wir da den Template-Helper, der den derzeitigen Beitrag holt und ihn an das Template weiterleitet.

Dann gibt es zwei Event-Callbacks in dem Template: Eines für das Event `submit` und eines für das Event `click` des Links zum Löschen des Beitrages.

Der Callback zum Löschen ist sehr einfach: Das Default-Event wird verhindert. Dann wird eine Bestätigung angefordert. Wenn wir diese erhalten, wird die derzeitige Id aus dem Datenkontext des Template genommen und anhand dieser gelöscht. Am Ende wird der Benutzer zur Homepage geleitet.

Der Callback zum Aktualisieren ist ein wenig länger, aber nicht wesentlich komplizierter. Nach dem Abschalten des Default-Events und dem Ermitteln der ID des Beitrags, entnehmen wir die Werte der neuen Felder aus der Seite und speichern diese in dem Objekt `postProperties`.

Dieses Objekt übergeben wir dass an die Meteor-Methode `Collection.update()`. Mit dem Callback wird ein Fehler angezeigt, wenn die Operation fehlgeschlagen ist. Falls die Operation erfolgreich war, leitet der Callback den Benutzer zurück auf die Seite des Beitrags zurück.

### Hinzufügen von Links

Wir sollten auch Links auf unsere Beträge anlegen. Damit haben unsere Möglichkeit die Seite für das Ändern von Beiträgen zu erreichen.

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
      <p>
        submitted by {{author}}
        {{#if ownPost}}<a href="{{pathFor 'postEdit'}}">Edit</a>{{/if}}
      </p>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>
<%= highlight "5~8" %>

Natürlich wollen wir dem Benutzer nicht einen Link für einen Beitrag zeigen, der im nicht gehört. Das erledigen wir mit dem Helper `ownPost`:

~~~js
Template.postItem.helpers({
  ownPost: function() {
    return this.userId == Meteor.userId();
  },
  domain: function() {
    var a = document.createElement('a');
    a.href = this.url;
    return a.hostname;
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>
<%= highlight "2~4" %>

<%= screenshot "8-1", "Formular für das Ändern von Beiträgen." %>

<%= commit "8-1", "Added edit posts form." %>

Unser Änderungsformular für Beiträge sieht gut aus. Aber du kannst derzeit noch gar nicht die Beiträge ändern. Warum ist das so?

### Einrichtung der Berechtigungen

Da wir im letztem Kapitel das Package `insecure` entfernt haben, werden alle client-seitigen Änderungen derzeit abgewiesen.

Um das wieder gerade zu biegen, werden wir ein paar Berechtigungsregeln anlegen. Als erstes erzeuge die neue Datei `permissions.js` im Verzeichnis `lib`. Diese soll unsere Berechtigungslogik enthalten und wird immer zuerst geladen (und ist sowohl in Server- als auch in Client-Umgebung verfügbar).

~~~js
// check that the userId specified owns the documents
ownsDocument = function(userId, doc) {
  return doc && doc.userId === userId;
}
~~~
<%= caption "lib/permissions.js" %>

Im Kapitel [Creating Posts](/chapter/creating-posts), whaben wir die Methode `allow()` entfernt, weil wir neue Posts nur noch per ServerMethode angelegt haben (diese umgeht sowieso`allow()`). 

Aber jetzt, wo wir Beiträge im Client ändern und löschen, schauen wir uns noch mal die Datei `posts.js` an und fügen den folgenden Block `allow()` hinzu:

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  update: ownsDocument,
  remove: ownsDocument
});

Meteor.methods({
  ...
~~~
<%= caption "collections/posts.js" %>
<%= highlight "3~6" %>

<%= commit "8-2", "Added basic permission to check the post's owner." %>

### Einschränkung von Änderungen

Nur weil du deine Beiträge ändern darfst soll das nicht heissen, dass dies für jede Eigenschaft des Beitrags gilt. Zum Beispiel wollen wir nicht, dass Benutzer das Erstellungs-Datum eines Beitrags ändern können und ihn dann jemand anders zuweisen können.

Wir Benutzer hierfür Meteors Callbakc `deny()` um sicherzustellen, dass Benutzer nur angegebene Felder ändern können:

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  update: ownsDocument,
  remove: ownsDocument
});

Posts.deny({
  update: function(userId, post, fieldNames) {
    // may only edit the following two fields:
    return (_.without(fieldNames, 'url', 'title').length > 0);
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "8~13" %>

<%= commit "8-3", "Only allow changing certain fields of posts." %>

Wir erhalten das Array `fieldNames`, dass eine Liste der Felder enthält, die geändert werden. Durch die Verwendung von [Underscore](http://underscorejs.org/)s Methode `without()` liefern wir eine Teilmenge des Arrays zurück in der Felder, die nicht `url` oder `title` heissen, fehlen

Im Normalfall sollte das Array leer sein und eine Länge von 0 haben. Wenn jemand etwas komisches probiert, wird die Array-Länge grösser gleich 1 sein. Dadurch liefert der Callback den Wert `true` zurück (und verhindert dadurch die Änderung).

<% note do %>

### Methodenaufrufe vs. Clientseitige Datenmanipulation

Um Beiträge zu erzeugen, benutzen wir die Server-Methode `post`. Aber zum Ändern und Löschen, rufen wir die Methoden `update` und `remove` direkt auf dem Client auf und regeln die Berechtigung mit `allow` und `deny`.

Wann ist es sinnvoll das eine oder das andere zu verwenden?

Wenn der Sachverhalt einfach ist, kannst du die Regeln mit `allow` und `deny` festlegen. Auch ist es meistens einfacher, die Dinge auf dem Client zu regeln.

Das Manipulieren der Daten vom Client aus erzeugt den Anschein von Direktheit und kann zu einem besseren Benutzererlebnis beitragen, solange du daran denkst Fehler elegant zu behandeln (zum Beispiel, wenn der Server sich asynchron zurückmeldet und mitteilt, dass die Änderung doch nicht stattgefunden hat)

Sobald du aber damit anfängst, Dinge zu tun, die ausserhalb des Einflussraums der Benutzer liegen soll (zum Beispiel die Vergabe von Zeitstempeln oder die Zuordnung eines Benutzers), ist es wahrscheinlich besser eine Server-Methode zu verwenden.

Server-Methoden sind in folgenden Szenarien ebenfalls angebracht:

- Wenn Du Rückgabewerte schnell benötigst und nicht darauf warten kannst, dass diese über den Reaktivitätsmechanismus synchronisiert werden. 
- Für Datenbankoperation, bei denen einen große Menge von Elementen geändert werden. Hierfür müssten komplette Collections hin und her übertragen werden müssen.
- Um Daten zusammenzufassen oder zu aggregieren (z.B. Anzahl der Elemente, Mittelwerte oder Summen)

<% end %>

